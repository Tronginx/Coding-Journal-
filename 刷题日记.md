# 刷题日记

## Array 数组

#### 5.8

占用连续的内存，查询O（1），插入删除O（N）

704 **binary search:**

第一遍看： 把nums分成两半，和target 进行比较，

if target 大于左边最小的 && 小于 left 中最大的就进入左边

else 进入右边

为什么pivot = (left + right) /2 是错的， 因为如果如果left + right 超过了integer的最大值，就会有问题

所以我们用 pivot = left  + (left-right)/2

难点：while loop 的条件是 left ≤ right

27.**Remove Element**

977 **Squares of a Sorted Array**

比较最左端 与最右端的绝对值

if left < right

square = nums[left]

left ++

else

square  = numsp[right]

rigth

1. **Minimum Size Subarray Sum**

**59. Spiral Matrix II**

```jsx
class Solution {
    public int[][] generateMatrix(int n) {
        int[][] res = new int[n][n];
        int layer = n+1/2;
        int fill = 1;
        for(int i =0;i<layer;i++){
            for(int one=i;one<=n-i-2;one++){
                res[i][one] = fill++;
            }
            for(int two=i;two<=n-i-2;two++){
                res[two][n-i-1] = fill++;
            }            
            for(int three=n-i-1;three>i;three--){
                res[n-i-1][three] = fill++;
            }               
            for(int four=n-i-1;four>i;four--){
                res[four][i] = fill++;
            }    
            if (n % 2 == 1) {
            res[n/2][n/2] = fill;
        }
            
        }

        return res;
    }
}
```

35.**Search Insert Position**

## Linked List 链表

#### 5.9

203. **Remove Linked List Elements**

```JAVA
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        
        ListNode sentinel = new ListNode(0);
        sentinel.next = head;
        
        ListNode prev = sentinel;
        ListNode curr = sentinel.next;
        
        while(curr != null){
            if(curr.val == val){
                prev.next = curr.next;            
            }
            else{
            prev = curr;

            }
            curr = curr.next;
        }
        
        return sentinel.next;

        

    }
}
```

- set sentinel/dummy node
- if curr.val == val, prev need to skip curr and connect to the next
- else prev move forward to curr
- Currently keep moving forward

707. **Design Linked List**

Will come back later



## 5.10

HashTable 



## 5.12